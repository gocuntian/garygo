### gob包管理gob流——在编码器（发送器）和解码器（接受器）之间交换的binary值。一般用于传递远端程序调用（RPC）的参数和结果，如net/rpc包就有提供。

### 本实现给每一个数据类型都编译生成一个编解码程序，当单个编码器用于传递数据流时，会分期偿还编译的消耗，是效率最高的。

## Basics
### Gob流是自解码的。流中的所有数据都有前缀（采用一个预定义类型的集合）指明其类型。指针不会传递，而是传递值；也就是说数据是压平了的。递归的类型可以很好的工作，但是递归的值（比如说值内某个成员直接/间接指向该值）会出问题。这个问题将来可能会修复。

### 要使用gob，先要创建一个编码器，并向其提供一系列数据：可以是值，也可以是指向实际存在数据的指针。编码器会确保所有必要的类型信息都被发送。在接收端，解码器从编码数据流中恢复数据并将它们填写进本地变量里。

## Types and Values
### 发送端和接收端的值/类型不需要严格匹配。对结构体来说，字段（根据字段名识别）如果发送端有而接收端没有，会被忽略；接收端有而发送端没有的字段也会被忽略；发送端和接收端都有的字段其类型必须是可兼容的；发送端和接收端都会在gob流和实际go类型之间进行必要的指针取址/寻址工作。举例如下：

    struct { A, B int }

### 可以和如下类型互相发送和接收：

    struct { A, B int }	// 同一类型
    *struct { A, B int }	// 结构体需要额外重定向（指针）
    struct { *A, **B int }	// 字段需要额外重定向（指针）
    struct { A, B int64 }	// 同为整型/浮点型且符号类型相同的不同值类型，参见下面
### 可以发送给如下任一类型：

    struct { A, B int }	// 同一类型
    struct { B, A int }	// 字段顺序改变无影响，按名称匹配
    struct { A, B, C int }	// 忽略多出的字段C
    struct { B int }	// 忽略缺少的字段A，会丢弃A的值
    struct { B, C int }	// 忽略缺少的字段A，忽略多出的字段C
### 但尝试发送给如下类型的话就会导致错误：

    struct { A int; B uint }	// B字段改变了符号类型
    struct { A int; B float }	// B字段改变了类型
    struct { }			// 无共同字段名
    struct { C, D int }		// 无共同字段名

### 整数以两种方式传递：任意精度有符号整数和任意精度无符号整数。Gob里只有无符号和有符号整数的区别，没有int8、int16等类型的区分。如下所述，发送端会以变长编码发送整数值；接收端接收整数并保存在目标变量里。浮点数则总是使用IEEE-754 64位精度（参见下述）。

### 有符号整数可以被任意有符号整形接收：int、int16等；无符号整数可以被任意无符号整形接收；浮点数可以被任意浮点数类型接收。但是，接收端类型必须能容纳该值（上溢/下溢都不行），否则解码操作会失败。

### 结构体、数组和切片都被支持。结构体只编码和解码导出字段。字符串和byte数组/切片有专门的高效表示（参见下述）。当解码切片时，如果当前切片的容量足够会被复用，否则会申请新的底层数组（所以还是用切片地址为好）。此外，生成的切片的长度会修改为解码的成员的个数。

### Gob流不支持函数和通道。试图在最顶层编码这些类型的值会导致失败。结构体中包含函数或者通道类型的字段的话，会视作非导出字段（忽略）处理。

### Gob可以编码任意实现了GobEncoder接口或者encoding.BinaryMarshaler接口的类型的值（通过调用对应的方法），GobEncoder接口优先。

### Gob可以解码任意实现了GobDecoder接口或者encoding.BinaryUnmarshaler接口的类型的值（通过调用对应的方法），同样GobDecoder接口优先。

## Encoding Details
### 这部分文档是编码细节，对多数使用者并不重要。细节是按从底向上的顺序展示的。

### 无符号整数用两种方法发送。如果该整数小于128，则以一个字节发送该值；否则采用最小长度大端在前的字节流保存该整数，并在最前面使用一个字节保存字节流的字节数相反数。因此0被发送为(00)，7被发送为(07)，而256被发送为(FE 01 00)（字节数2，其相反数-2，用补码表示，为FE）。

### 布尔值按无符号整数编码，0表示假，1表示真。

### 有符号整数翻译为一个无符号整数（i=>u）来编码。u的最低字位表示值的符号（以及是否应对值按位取反）；其余位表示值。编码算法表示为如下（非实际代码）：

    uint u;
    if i < 0 {
        u = (^i << 1) | 1	// i按位取反，左移1位，第1位设为1
    } else {
        u = (i << 1)	// i不进行取反，左移1位，第1位为0
    }
    encodeUnsigned(u)
### 这样一来，最低位就相当于标志位，但还会对负数按位取反，以便保证负数不会出现特殊情况（补码表示的负数，其表示会受到整数类型的影响）。如，-129=^128=(^256>>1)编码为(FE 01 01)。

### 浮点数的数值，首先总是转换float64类型值，该值使用math.Float64bits 函数转换为一个uint64整数，然后将字节序颠倒过来，最后作为一个普通无符号数编码传输。颠倒字节序说明数字的指数和高精度位数部分首先传送。因为低位一般是0，这样可以节约编码的字节数。例如，17.0编码后只有三个字节(FE 31 40)。

### 字符串和byte数组/切片发送为一个无符号整数指定的字节数后跟不作处理的字节序列。

### 其它切片和数组都发送为一个无符号整数指定的成员个数后跟所有成员的递归表示的gob编码。

### 映射发送为一个无符号整数指定的键值对数后给许多键和值的gob编码。非nil但无成员的映射也会发送，因此如果发送者申请了一个映射，接收方也会申请一个映射，即使该映射内没有元素。

### 结构体也以键值对（字段名：字段值）序列的形式发送。字段值采用递归表示的gob编码发送。如果字段为其类型的零值，则该字段不会被发送。字段编号由编码的结构体的类型确定：编码类型的第一个字段为字段0，第二个为字段1，依次类推。当编码一个结构体的值时，字段编号出于效率考虑是增量编码的，字段总是按字段编号递增的顺序被编码，增量是无符号整数。增量编码将字段编号初始化为-1，因此无符号整型值为7的字段0编码为增量1值7。最后，所有的字段都被发送后，会发送终止标记表明结构体的结束。终止标记为一个增量为0的值，其表示为(00)。

### 接口类型不会检查兼容性；所有的接口都被视为同一种“接口”类型来传输；类似整数和字节切片，它们都被视为interface{}类型。接口值发送为一个表示其具体类型的字符串标志符（必须由调用者预先注册的名称）后跟表示后续数据字节数的无符号整数（以便需要时可以跳过该值），再后跟保存在接口里的值的动态具体类型的gob编码。nil接口值会发送为标志符为空字符串、不发送值的接口。在接收到之后，由解码器验证该值是否满足接收端变量接口。

### 类型的表示如下所示。当一个编码器和解码器的连接中定义了一个类型时，该类型会被指定一个整数类型ID。当调用Encoder.Encode(v)时，该方法会确保v及v所有成员都有对应ID，然后本方法会发送一系列对（typeid，encoded-v） ，其中typeid是编码类型的类型ID，encoded-v是值v的gob编码。

### 为了定义一个类型，编码器会选择一个未使用的正数作为id并发送对（-type id, encoded-type），其中encoded-type 是由如下类型构成、描述该类型的wireType类型的gob编码




gob是Golang包自带的一个数据结构序列化的编码/解码工具。编码使用Encoder，解码使用Decoder。一种典型的应用场景就是RPC(remote procedure calls)。

gob和json的pack之类的方法一样，由发送端使用Encoder对数据结构进行编码。在接收端收到消息之后，接收端使用Decoder将序列化的数据变化成本地变量。

 

有一点需要注意，

发送方的结构和接受方的结构并不需要完全一致

结构体中缺省的字段将不会被发送。而且在接收方，并不需要所有的字段都要有对应的结构属性对应。godoc中的这个例子很形象：
整型：分为sign int和usign int， 其中从上面例子也看到，int和uint是不能互相编解码的。float和int也是不能互相编解码的。

Struct，array，slice是可以被编码的。但是function和channel是不能被编码的。

bool类型是被当作uint来编码的，0是false，1是true。

浮点类型的值都是被当作float64类型的值来编码的

String和[]byte传递是uint(byte个数) + byte[]的形式编码的

Slice和array是按照uint(array个数) + 每个array编码 这样的形式进行编码的

Maps是按照 uint(Map个数) + 键值对 这样的形式进行编码的

 

Struct是按照一对对（属性名 + 属性值）来进行编码的。其中属性值是其自己对应的gob编码。前面说过，如果有一个属性值为0或空，则这个属性直接被忽略。每个属性的序号是由编码时候顺序决定的，从0开始顺序递增。Struct在序列化前会以-1代表序列化的开始，以0代表序列化结束。即Struct的序列化是按照 “-1 （0 属性1名字 属性1值） （1 属性2名字 属性2值） 0 ”来进行编码的。

 

非常重要的一点：

Struct中的属性应该是public的，即应该是大写字母开头。


这个代码要注意几个地方：
1 P和Q是两个结构体，应该说是“相似”的两个结构体

2 Encode是将结构体传递过来，但是Decode的函数参数却是一个pointer！

这点在godoc中有说：

f e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received.

Decode的参数如果不是nil，那就一定是一个指针了。